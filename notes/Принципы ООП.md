---
tags:
  - "#инкапсуляция"
  - "#Наследование"
  - "#Полиморфизм"
  - "#Абстракция"
  - "#Override"
  - "#overloading"
  - "#Ad-hoc"
  - Переопределение
  - перегрузка
---
В методологии объектно-ориентированного программирования (ООП) есть четыре ключевых принципа:

·         инкапсуляция,
·         наследование,
·         полиморфизм,
·         абстракция.

## Инкапсуляция

#инкапсуляция

**_Инкапсуляция_** (от англ. encapsulation и **от лат. in capsula — в капсуле) — это концепция, согласно которой данные и методы для работы с ними объединяются в «капсуле», например, внутри класса.

Инкапсуляция важна по следующим причинам:

**_Не нужно знать, как устроен внутренний процесс, достаточно внешнего интерфейса._**

Инкапсуляция предусматривает **_сокрытие_** внутреннего устройства объектов класса — взаимодействие с ними происходит при помощи внешнего интерфейса.

Преимущества:

·         Высокая скорость понимания кода.
·         Удобство работы с кодом.
·         Минимизация ошибок и надёжное хранение данных.

В коде инкапсуляция реализуется за счёт следующих инструментов:

·         методов, включая set- и get- методы
·         пакетов
·         модификаторов доступа.

Пакеты структурируют классы в программе. Сокрытие данных достигается с помощью модификаторов доступа: private, public, protected и модификатора по умолчанию default (package-private) — каждый из них определяет свой уровень доступности. Методы позволяют реализовать интерфейс. С помощью set- и get- методов можно настроить доступ к данным.

## Наследование

#Наследование

 (от англ. “inheritance”). Призван решить проблему повторения кода.

Благодаря наследованию дочерние классы автоматически приобретают функционал класса-родителя. Не нужно раз за разом прописывать одни и те же поля и методы — их можно передать по наследству.

У классов в Java может быть сколько угодно предков, но только один родитель. То есть при помощи ключевого слова extends можно наследовать только от одного класса.

При внесении изменений в родительский класс они автоматически перейдут по наследству.

Класс-родитель, или класс-предок, иначе ещё называют **_суперклассом_**. Классы-потомки — **_подклассами_**.

Подкласс наследует все поля и методы суперкласса, которые имеют области видимости public, protected или package-private (если класс-потомок находится в одном пакете с классом-родителем). Данные, помеченные модификатором private, при расширении с помощью extends не передаются.

После расширения с помощью extends в классе-наследнике можно делать следующее:

·         Использовать унаследованные поля и методы напрямую.

·         Можно объявить новые поля и методы, которых нет в суперклассе.

·         Можно объявить поле в подклассе с таким же именем, что и поле в суперклассе, — это называется сокрытием (англ. hiding). Увлекаться им не стоит — в результате получается два класса, один из которых наследует от другого и в обоих есть одинаковые поля. Если произойдёт ошибка — найти её будет сложно.

·         Можно переопределить методы: реализовать в подклассе методы, которые будут иметь ту же сигнатуру, что и в суперклассе, но отличаться своим поведением.

·         Можно написать конструктор, который будет вызывать конструктор суперкласса.

**_В экземплярах суперкласса нельзя использовать поля и методы подклассов._** То есть если у классов-наследников появились новые свойства и функционал, то передать их в класс-родитель не получится.

Также **_в классе-наследнике нельзя сузить видимость полей или методов — можно только расширить_**.

### Переопределение методов

#Переопределение #Override

Чтобы изменить поведение метода суперкласса, его можно переопределить внутри подклассов. Механизм переопределения предполагает, что сигнатура остаётся прежней, при этом в тело метода вносятся изменения, а доступ к нему может быть расширен.

Переопределение метода помечается в коде с помощью аннотации @Override (от англ.  override — «переопределение, ручная коррекция»).

Отсутствие аннотации @Override при переопределении метода — не ошибка. Однако её принято использовать, так как у неё есть два полезных свойства:

·         Явно обозначены переопределённые методы — их легко отличить от остальных методов класса.

·         Если в переопределённом методе, помеченном @Override, поменяется сигнатура (неважно где: в классе-родителе или классе-наследнике), то при компиляции появится сообщение об этом. Method does not override from its superclass — это означает, что метод больше не переопределяется из своего суперкласса.

## Абстракция

#Абстракция

(англ. abstraction, «отвлечение»), применительно к ООП, это принцип, при котором пользователю класса доступны только методы, описывающие основное поведение, а остальные детали скрыты внутри реализации. Одним из инструментов для достижения абстракции является инкапсуляция. Используя этот принцип, программист описывает, что делает класс, а не то как он это делает.

## Полиморфизм

#Полиморфизм

Полиморфизм (в переводе с греческого означает «многообразный») — это способность принимать разные формы.

В применении к языкам программирования полиморфизм означает способность программы одинаково работать с объектами, если они имеют одинаковый интерфейс.

Выделяют несколько видов:

·         Классический полиморфизм;

·         Ad-hoc полиморфизм, который делится на два подвида:

o    Динамический,

o    Статический;

·         Параметрический полиморфизм.

### Классический полиморфизм

Если разные классы имплементируют одинаковый интерфейс или наследуются от одного класса, их объекты будут вести себя одинаково. Это позволяет программе работать с ними одинаковым образом — независимо от их типа.

### Динамический ad-hoc полиморфизм

#Ad-hoc

используется, чтобы поменять поведение класса, не меняя его код.

Ad-hoc-полиморфизм («специальный полиморфизм»).

Динамический полиморфизм тесно связан с наследованием и заключается в переопределении (англ. overriding) методов — он позволяет им демонстрировать различное поведение при вызове для разных типов. Если в программе есть переменная с типом родителя и в ней хранится объект класса-наследника, то при вызове метода, который определён и там, и там, будет вызван метод класса-наследника.

### Статический ad-hoc полиморфизм

#перегрузка  #overloading

позволяет расширить интерфейс класса через перегрузку метода

Статический ad-hoc полиморфизм — это перегрузка (англ. overloading) метода. В классе может быть несколько методов с одинаковым названием, но с разными типами параметров. В этом случае компилятор сам выберет нужную реализацию — в зависимости от типа переданного аргумента, который становится известен на этапе компиляции.

Помните, что **_перегрузка (overloading) возможна для методов одного класса, в то время как переопределение (overriding) возможно только при наличии нескольких классов/интерфейсов._**

### Параметрический полиморфизм

вид полиморфизма, позволяющий реализовать поведение класса или метода с указанием параметров и возвращаемых значений общего вида вместо конкретных. Это бывает удобно, когда классу всё равно, данные какого типа он будет использовать: он будет одинаково работать со значениями вне зависимости от их типа.