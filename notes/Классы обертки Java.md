---
tags:
  - "#NaN"
---
Для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами (ссылочными типами) были придуманы классы-обёртки.

Классы обертки нужны
1. Для хранения примитивов в коллекции
2. Для использования в дженериках (Generics)
3. Когда нужно выразить в программе факт отсутствия значения (можно хранить Null)
	**Важно использовать [[Класс Optional]] для удобной отработки возможного null значения**

>[!WARNING] 
>Классы-обёртки неизменяемые (Immutable)
>Поэтому при каждой автоупаковке (за исключением значений из pool) создается новый объект, что может привести к неразумному расходу памяти.

**Например**, завернём примитивный int в объект класса Integer. Что при этом происходит в памяти?
Примитивный int – это 4 байта памяти, в которых лежит значение. Ссылочный Integer – это ссылка на объект Integer, лежащий в куче, а внутри этого объекта лежи примитивное значение int.
![[Классы обертки хранение.png]]

## Обертки примитивных типов

| Primitive Data Types | Wrapper Classes |
|----------------------|-----------------|
| int                  | **Integer**         |
| short                | Short           |
| long                 | Long            |
| byte                 | Byte            |
| float                | Float           |
| double               | Double          |
| char                 | **Character**       |
| boolean              | Boolean         |

## Вывод
**Примитивы:**
-   имеют преимущество в производительности

**Обертки:**
-   Позволяют не нарушать принцип “все является объектом”, благодаря чему числа, символы и булевы значения true/false не выпадают из этой концепции
-   Расширяют возможности работы с этими значениями, предоставляя удобные методы и поля
-   Необходимы, когда какой-то метод может работать исключительно с объектами

## Автоупаковка автораспаковка
Процесс преобразования примитивных типов в эквивалентные объекты (ссылочный тип) называется автоупаковкой (autoboxing), а обратный ему — автораспаковкой (unboxing).

**Автоупаковка/автораспаковка не работает для массивов!**
``` java
int primitive 0;
Integer reference = Integer.valueOf(primitive);
int backToPrimitive = reference.intValue();
```

## Преобразования типов
![[Явные и неявные преобразования типов.png]]
### Явные
Это явное сужение от большего к меньшему.
Необходимо явно указать сужаемый тип.
![[Потеря данных при преобразовании.png]]


В случае с объектами мы можем делать неявное (автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.
### Неявные (безопасные)
Автоматическое расширение типа переменной от меньшего к большему
Старшие разряды более широкого типа просто заполняются знаковым битом исходного значения.
![[Преобразования типов с потерей точности.png]]
![[Почему происходит потеря точности при приведении типов.png]]
![[Преобразование вещественных чисел в целочисленные.png]]

## Приведение примитивных типов

Приведение типов (**type casting**). Иногда возникают ситуации, когда у вас есть величина какого-то определенного типа, а вам нужно ее присвоить переменной другого типа. Для некоторых типов это можно проделать и без приведения типа, в таких случаях говорят об автоматическом преобразовании типов. 
В Java автоматическое преобразование возможно только в том случае, когда точности представления чисел переменной-приемника достаточно для хранения исходного значения. Такое преобразование происходит, например, при занесении литеральной константы или значения переменной типа byte или short в переменную типа int. Это называется расширением (**widening**) или повышением (**promotion**), поскольку тип меньшей разрядности расширяется (повышается) до большего совместимого типа. Размера типа int всегда достаточно для хранения чисел из диапазона, допустимого для типа byte, поэтому в подобных ситуациях оператора явного приведения типа не требуется. Обратное в большинстве случаев неверно, поэтому для занесения значения типа int в переменную типа byte необходимо использовать оператор приведения типа. Эту процедуру иногда называют сужением (narrowing), поскольку вы явно сообщаете транслятору, что величину необходимо преобразовать, чтобы она уместилась в переменную нужного вам типа. Для приведения величины к определенному типу перед ней нужно указать этот тип, заключенный в круглые скобки. В приведенном ниже фрагменте кода демонстрируется приведение типа источника (переменной типа int) к типу приемника (переменной типа byte). Если бы при такой операции целое значение выходило за границы допустимого для типа byte диапазона, оно было бы уменьшено путем деления по модулю на допустимый для byte диапазон (результат деления по модулю на число — это остаток от деления на это число).

int a = 100;

byte b = (byte) a;

Результат промежуточного выражения (а* b) вполне может выйти за диапазон допустимых для типа byte значений. Именно поэтому Java автоматически повышает тип каждой части выражения до типа int, так что для промежуточного результата (а* b) хватает места.

**Автоматическое преобразование типа** иногда может оказаться причиной неожиданных сообщений транслятора об ошибках. Например, показанный ниже код, хотя и выглядит вполне корректным, приводит к сообщению об ошибке на фазе трансляции. В нем мы пытаемся записать значение 50* 2, которое должно прекрасно уместиться в тип byte, в байтовую переменную. Но из-за автоматического преобразования типа результата в int мы получаем сообщение об ошибке от транслятора — ведь при занесении int в byte может произойти потеря точности.

byte b = 50;

b = (byte) (b* 2);

Если в выражении используются переменные типов byte, short и int, то во избежание переполнения тип всего выражения автоматически повышается до int. Если же в выражении тип хотя бы одной переменной — long, то и тип всего выражения тоже повышается до long. He забывайте, что все целые литералы, в конце которых не стоит символ L (или 1), имеют тип int.

Если выражение содержит операнды типа float, то и тип всего выражения автоматически повышается до float. Если же хотя бы один из операндов имеет тип double, то тип всего выражения повышается до double. По умолчанию Java рассматривает все литералы с плавающей точкой, как имеющие тип double.

Любой из целочисленных типов при необходимости будет автоматически расширен до дробного. Дело в том, что диапазон меньшего из дробных примитивов float включает диапазон большего из целочисленных типов long. Сравните: в long можно хранить числа примерно от -9*1018 до 9*1018, а в переменных типа float от -3.4*1038 до 3.4*1038

### Деление целых и вещественных чисел в Java

При делении целого числа на целое остаток всегда отбрасывается. Как же тогда, скажем, поделить 5 на 2, чтобы получить 2.5?

Поначалу кажется, что правильный вариант такой:

`double d = 5 / 2;

Однако не все так просто. Дело в том, что Java-машина сначала вычислит значение выражения 5 / 2 и только потом присвоит результат в переменную d. А деление 5 / 2 выполнится нацело. Т.е. d будет содержать 2 или, если быть более точным, 2.0

Правильный вариант такой: хотя бы одно из чисел, участвующих в делении, нужно записать как вещественное (т.е. с точкой):

`double d = 5.0 / 2;

`double d = 5 / 2.0;

`double d = 5.0 / 2.0;

В любом из этих выражений d будет содержать значение 2.5

А как же быть с переменными? Что если у нас есть такой код:

`int a = 5;

`int b = 2;

`double d = a / b;

Тут есть хитрое (и очевидное) решение — заставить Java-машину преобразовать переменные в вещественные, умножив их на вещественную единицу — 1.0

`int a = 5;

`int b = 2;

`double d = a * 1.0 / b;

Обратите внимание, что у операций умножения и деления равный приоритет, и они выполняются слева направо, поэтому имеет значение, где именно мы умножаем на вещественную единицу.

`int a = 5;

`int b = 2;

`double d = 1.0 * a / b; // (1.0 * a) / b;   2.5

`int a = 5;

`int b = 2;

`double d = a * 1.0 / b; // (a * 1.0) / b;   2.5

`int a = 5;

`int b = 2;

`double d = a / b * 1.0; // (a / b) * 1.0;   2.0

Когда Java не знает, каким будет результат операции — может получиться целое число, а может и дробное, то сохраняет результат в дробном виде. По сути здесь происходит автоматическое расширяющее приведение целых типов к дробным. Это нужно, чтобы никакая информация не потерялась.

### Бесконечность

Числа с плавающей точкой обладают еще одной интересной особенностью: они позволяют хранить специальное значение, обозначающее бесконечность. Причем может быть положительная бесконечность и отрицательная бесконечность.

```java
System._out_.println( 100.0 / 0.0 );  // Infinity

System._out_.println( -100.0 / 0.0 );  // - Infinity

double a = 1d / 0d;  // a == Infinity
double b = a * 10;  // b == Infinity
double c = b - 100;  // c == Infinity
```

### Не число (NaN)

Любые операции с бесконечностью дают бесконечность. В целом да, но не все.

Числа с плавающей точкой могут хранить еще одно специальное значение — NaN. Это сокращение от Not a Number (не число).

В математике, если разделить бесконечность на бесконечность, должна возникнуть неопределенность.

Ну, а в Java, если разделить бесконечность на бесконечность, будет NaN.

```java
System._out_.println(0.0 / 0.0); _// NaN_

double infinity = 1d / 0d;
System._out_.println(infinity / infinity); _// NaN_
```

## Приведение ссылочных типов

Так как класс содержит все методы класса, от которого он был унаследован, то объект этого класса можно сохранить в переменную любого из его типов родителей.

```java
class Animal {
	public void doAnimalActions(){
}

class Cat extends Animal {
	public void doCatActions(){
	}
}

class Tiger extends Cat {
	public void doTigerActions(){
	}
}
```

Тут мы видим три объявленных класса: животное, кот и тигр. Кот наследуется от Животного. А Тигр от Кота.
```java
public static void main(String[] args) {
	Tiger tiger = new Tiger();
	Cat cat = new Tiger();
	Animal animal = new Tiger();
	Object obj = new Tiger(); 
}
```

Объект класса Tiger всегда можно спокойно присвоить переменной с типом класса-родителя. Для класса Tiger – это Cat, Animal и Object.

Если в результате присваивания мы двигаемся по цепочке наследования вверх (к типу Object), то это — расширение типа (оно же — восходящее преобразование или upcasting), а если вниз, к типу объекта, то это — сужение типа (оно же — нисходящее преобразование или downcasting).

Движение вверх по цепочке наследования называется расширением, поскольку оно приводит к более общему типу. Но при этом теряется возможность вызвать методы, которые были добавлены в класс при наследовании.

```java
public static void main(String[] args) {
	Object obj = new Tiger();
	Animal animal = (Animal) obj;
	Cat cat = (Cat) obj;
	Tiger tiger = (Tiger) animal;
	Tiger tiger2 = (Tiger) cat;
}
```

При сужении типа, нужно использовать оператор преобразования типа, то есть мы выполняем явное преобразование.

При этом Java-машина выполняет проверку, а действительно ли данный объект унаследован от Типа, к которому мы хотим его преобразовать.

Такое небольшое нововведение уменьшило количество ошибок в преобразовании типов в разы, и существенно повысило стабильность работы Java-программ.

**_С объектом при таком присваивании ничего не происходит! Меняется только количество методов, которое можно вызвать с помощью конкретной переменной-ссылки._**

## Методы классов-обёрток

### .parseInt

У всех классов-обёрток, кроме Character, есть метод, позволяющий преобразовывать строки в свой тип. На профессиональном сленге это называется «парсить» строки (от англ. parse — «разбирать»). Это происходит с помощью метода parse.

```java
String input = "1000";

Integer number = Integer.parseInt(input); 
```

Важно, чтобы в строку было записано именно число, а не его буквенное выражение или какая-то последовательность.

### .max() и .min()

С помощью методов классов-обёрток Integer, Long, Float и Double можно находить максимальное и минимальное значение из двух вариантов. Методы max() и min() вызываются также с помощью имени класса-обёртки и точечной нотации. Они возвращают примитив.

```java
long a = 142_858_234;

long b = 9_123_456_678L;

long maximum = Long.max(a, b);
```

У классов Byte и Short методов по поиску максимального и минимального значения нет. При работе с переменными типов byte и short минимум и максимум можно вычислить при помощи соответствующих методов класса Integer. Для этого нужно воспользоваться явным приведением типов.

### .shortValue()

Для приведения переменных классов-обёрток к примитивам можно ещё воспользоваться встроенным методом [имя примитива, к которому нужно привести]value().
```java
Long bigNumber = 10L;

short smallNumber = bigNumber.shortValue();
```