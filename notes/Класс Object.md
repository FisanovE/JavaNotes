---
tags:
  - Java/ООП
  - Object
  - equals
  - hashCode
  - toString
---
входит в пакет java.lang

Наследование от класса Object происходит по умолчанию. Расширение при помощи extends не требуется.

Переменной типа Object можно присвоить любое ссылочное значение. Это может быть объект любого класса, например, список, массив или ваш собственный, а также значение примитивного типа после автоупаковки в класс-обёртку.

Благодаря тому, что Object может хранить любой объект, его удобно использовать как параметр универсального метода, который должен принимать объекты разных классов.

```
public boolean equals(Object obj) – возвращает результат проверки объектов на равенство.

public boolean equals(Object obj) – возвращает результат проверки объектов на равенство.

public final Class<?> getClass() - возвращает класс объекта во время выполнения.

public int hashCode() - возвращает хэш-код, связанный с вызывающим объектом.

public String toString() - возвращает строковое представление объекта.

protected Object clone() – возвращает копию объекта.
```

сложно переопределять и он редко используется

**_нельзя переопределить:_**

```
public final void wait() – освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока его работу не прервут или не известят об окончании ожидания.

public final void wait(long timeout) – то же что и wait, но можно указать время ожидания в миллисекундах.

public final void wait(long timeout, int nanos) - то же что и wait, но можно указать время ожидания в миллисекундах и наносекундах.

public final void notify() - возобновляет работу одного из потока, которые ранее вызывали метод wait.

public final void notifyAll() - возобновляет исполнение всех потоков, которые ранее вызывали метод wait.

protected void finalize() - вызывается перед удалением неиспользуемого объекта.
```
## Переопределение equals ()

#equals

Чтобы сравнить объекты через метод equals(Object), нужно его переопределить. В базовой реализации класса Object метод выглядит так:
```java
public boolean equals(Object obj) { // реализация по умолчанию
    return (this == obj);
}
```
Во многих классах стандартной библиотеки метод equals(Object) уже переопределён. Это даёт возможность применять его автоматически.

Для сравнения объектов собственных классов, будь то книги, хомяки или космические корабли, метод equals(Object) нужно переопределить.

```java
public class Book {
    public String title;
    public String author;
    public int pagesNumber;
    
    public Book(String title, String author, int pagesNumber) {
        this.title = title;
        this.author = author;
        this.pagesNumber = pagesNumber;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true; // проверяем адреса объектов
        if (obj == null) return false; // проверяем ссылку на null
        if (this.getClass() != obj.getClass()) return false; // сравниваем классы
        Book otherBook = (Book) obj; // открываем доступ к полям другого объекта
        return Objects.equals(title, otherBook.title) && // проверяем все поля
               Objects.equals(author, otherBook.author) && // нужно логическое «и»
               (pagesNumber == otherBook.pagesNumber); // примитивы сравниваем через ==
	    }
	}
}
```
Так вы сразу вычислите, не имеете ли дело с одним и тем же объектом. Если это так, то нет смысла дальше проверять все поля на равенство, можно сразу вернуть положительный результат.

Следующим шагом нужно проверить, не была ли передана в метод equals(Object) пустая ссылка null вместо объекта. Если аргумент равен null — можно сразу возвращать отрицательный результат.

Если вовремя не отловить null и продолжать дальнейшую проверку пустой ссылки, это приведёт к генерации исключения NullPointerException.

Поскольку базово метод equals(Object) принимает в качестве аргумента объекты любых классов, дальше требуется проверить, что в него передан экземпляр нужного. В примере это класс Book. Провести такую проверку поможет другой метод класса Object — getClass(). Этот метод возвращает информацию о том, к какому классу относится объект. Если классы у сравниваемых объектов отличаются, то вернётся false.

Первая часть переопределения метода завершена — исключено, что это один и тот же объект, экземпляры разных классов или передана пустая ссылка. Эти проверки нужно провести вне зависимости от того, объекты каких классов вы сравниваете между собой.

Далее нужно привести переданный объект к тому классу, где переопределяется equals(Object).

Приведение типов нужно, чтобы получить доступ к полям второго объекта. После этого можно обращаться к ним по выбранному имени (otherBook), используя точечную нотацию.

Вторая часть переопределения метода equals(Object) касается сравнения полей объектов. В классе Book три поля title — название, author — автор и pagesNumber — количество страниц. Нужно проверить, что их значения совпадают и что объектные поля не содержат пустую ссылку null (исключена ошибка NullPointerException).

Для сравнения полей удобно пользоваться методом Objects.equals(Object, Object). Утилитарный класс Objects (c s на конце - https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html) содержит набор вспомогательных методов, в том числе equals(Object, Object). Этот метод сначала проверяет, не равны ли переданные аргументы пустым ссылкам, и если нет — сравнивает их. Поля примитивных типов сравниваем через оператор == 

## Проверка после переопределения

Переопределить метод equals(Object) не так уж и просто. Поэтому в некоторых случаях это не требуется — например, когда класс несёт сервисную или утилитарную функциональность или был создан только ради использования его методов. Также можно унаследовать переопределённый equals(Object) с подходящей реализацией.

Если всё-таки требуется написать новую реализациюequals(Object), то она должна соответствовать контракту метода — своду правил, закреплённых в документации. Разберём их:

**Правило рефлексивности** — объект должен быть равен самому себе. То есть вызов x.equals(x) должен всегда возвращать true.

**Правило симметричности** — «от перестановки мест слагаемых сумма не меняется». Результат сравнения объектов не зависит от того, в каком порядке они расположены. Вызов x.equals(y) должен возвращать true в то же время, когда вызов y.equals(x) возвращает true.

**Правило логической транзитивности** — если два объекта равны и один из них равен третьему, то все три объекта равны. Так, если вызов x.equals(y) возвращает true и y.equals(z) возвращает true, то вызов x.equals(z) также должен вернуть true.

**Правило согласованности** — если не менять данные сравниваемых объектов, то и результат их сравнения должен быть всегда одинаков. То есть множественный вызов x.equals(y) должен возвращать один и тот же результат до тех пор, пока данные полей объектов x и y неизменны.

**Правило «на ноль делить нельзя»** — ни один из сравниваемых объектов не может быть равен null. Это значит, что вызов x.equals(null) должен всегда возвращать false.

## Переопределение hashCode()

#hashCode

Вместе с методом equals(Object) сразу стоит переопределить другой метод Object — hashCode(). Он оптимизирует хранение и поиск объектов в коллекциях, таких как HashMap и других.

Базовая реализация метода hashCode() стремится создать уникальный хеш для каждого объекта, в том числе для идентичных. При переопределении нужно это исправить.

💡 **_У всех стандартных ссылочных типов данных в Java (String, Integer, Double и т. д.) методы equals(Object) и hashCode() уже корректно переопределены. Поэтому их можно спокойно использовать с коллекциями HashMap, HashSet и прочими._**

Чтобы хеш-коды разных объектов отличались, а одинаковых — совпадали, нужно вычислять хеш в связке с методом equals(Object). Оба метода должны зависеть от одних и тех же полей. Отсюда и взялось правило, что при переопределении equals(Object) лучше сразу переопределять метод hashCode().

Более простой и самый распространённый вариант переопределения hashCode() — через метод hash(Object... values) класса Objects.

```java
import java.util.Objects;

public class Person {
    public String firstName;
    public String lastName;
    
    public Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return Objects.equals(firstName, person.firstName) &&
                Objects.equals(lastName, person.lastName);
    }

    @Override
    public int hashCode() {
        // вызываем вспомогательный метод и передаём в него нужные поля
        return Objects.hash(firstName, lastName);
    }
}
```

Метод hash(Object... values) позволяет эффективно работать с поиском данных в коллекциях, в том числе хеш-таблицах. Его рекомендуется использовать в тех случаях, когда нет необходимости как-то дополнительно оптимизировать работу hashCode().

У метода hashCode() есть контракт), которым нужно руководствоваться при его ручном переопределении. Он включает три правила:

·         Если при сравнении методом equals(Object) объекты оказались равны, то hashCode() должен возвращать у каждого из них одно и то же число.

·         Метод hashCode() должен возвращать одно и то же целое число до тех пор, пока значения полей, используемых в методе equals(Object)того же класса, остаются прежними.

·         Нужно стремиться к тому, чтобы у объектов, которые не равны при сравнении equals(Object), были разные хеш-коды, но учитывать, что они могут совпасть. Поэтому, если у двух объектов одинаковые хеш-коды, нельзя утверждать, что объекты равны. Точный результат покажет только метод equals(Object).

Если подытожить, переопределяя метод hashCode(), важно проверить, чтобы для равных объектов всегда возвращался одинаковый хеш-код, а для разных по возможности разные.

## Переопределение toString()

#toString

Так же, как equals(Object) и hashCode(), метод toString() рекомендуется всегда переопределять. Его базовая реализация в классе Object не информативна — не учитывает поля каждого класса.

Так как у toString() нет строгого контракта, при его переопределении принято руководствоваться вот такими рекомендациями:

**_1. Единый формат._**

Когда вывод toString() построен во всех классах по одной и той же логике — код удобно читать и воспринимать. Детали могут отличаться, но основа должна быть единой. В начале указывается имя класса, затем в фигурных скобках названия полей и их значения:

```java
@Override
public String toString() {
    return "Address{" + // имя класса
            "city='" + city + '\'' + // поле1=значение1
            ", street='" + street + '\'' + // поле2=значение2
            ", houseNumber=" + houseNumber + // поле3=значение3
            '}';
}
// будет напечатано: Address{city='Санкт-Петербург', street='Кирочная', houseNumber=19}
```

Важно запомнить, что toString() не должен влиять на состояние объекта. Он работает в режиме «только чтение» — не меняет значения полей и не проводит с ними расчёты.

**_2. Лаконичность и информативность._**

·         В реализацию toString() стоит включать только те поля, которые содержат ключевую или определяющую информацию. Статические или вспомогательные поля можно опустить.

·         Реализацию toString() важно поддерживать в актуальном состоянии. Добавлять поля или удалять их по мере необходимости.

·         Некоторые поля могут содержать объёмные данные. Нет практического смысла в том, чтобы выводить их полное или даже сокращённое содержание. Можно отобразить их длину.

К примеру, добавим в Address поле extraInfo. В нём будет храниться дополнительная информация об адресах — историческая справка или архитектурный статус. Чтобы не выводить значение этого поля полностью, оставим в toString() только его размер:

```java
class Address {
    public String city;
    public String street;
    public int houseNumber;
    public String extraInfo;
    public Address(String city, String street, int houseNumber, String extraInfo) {

        this.city = city;
        this.street = street;
        this.houseNumber = houseNumber;
        this.extraInfo = extraInfo;
    }

    @Override
public String toString() {

    return "Address{" +
            "city='" + city + '\'' +
            ", street='" + street + '\'' +
            ", houseNumber=" + houseNumber + '\'' +
            ", extraInfo.length=" + extraInfo.length() + // выводим не значение, а длину
            '}';
    }
}
```

Вывести длину вместо содержания также может быть удобно для полей-массивов или других коллекций.

**_3. Профилактика исключений NullPointerException._**

Оператор конкатенации + умеет работать с пустыми ссылками null, поэтому при сложении строк с пустой ссылкой ошибки не будет. Исключение NullPointerException может возникнуть в том случае, если у одного из полей вызывается метод — в нашем примере у поля extraInfo перед конкатенацией вызывается метод length. Избежать ошибки можно так:

```java
@Override
    public String toString() {

        String result = "Address{" +
                "city='" + city + '\'' +
                ", street='" + street + '\'' +
                ", houseNumber=" + houseNumber + '\'';

        if(extraInfo != null) { // проверяем, что поле не содержит null
            result = result + ", extraInfo.length=" + extraInfo.length(); // выводим не значение, а длину
        } else {
            result = result + ", extraInfo=null"; // выводим информацию, что поле равно null
        }
        return result + '}';
    }
```

**_4. Форматирование данных._**

Некоторые типы данных требуют дополнительного форматирования. Это актуально, к примеру, для массивов. Они наследуют базовую реализацию toString(), и чтобы посмотреть их содержание, лучше дополнительно вызвать метод toString(Object[] a) класса Arrays.. Этот метод проверяет массив на null и если всё в порядке, возвращает его текстовое представление.

```java
@Override
    public String toString() {
    
        String result = "Address{" +
                "city='" + city + '\'' +
                ", street='" + street + '\'' +
                ", houseNumber=" + houseNumber + '\'';

        if(extraInfo != null) { // проверяем, что поле не содержит null
            result = result + ", extraInfo.length=" + extraInfo.length(); // выводим не значение, а длину
        } else {
            result = result + ", extraInfo=null"; // выводим информацию, что поле равно null
        }
        return result +
                // форматируем массив с помощью метода Arrays.toString
                ", residents=" + Arrays.toString(residents) +
                '}';
    }
}
```

В отдельном форматировании могут также нуждаться такие данные, как даты (например, месяц указывать текстом или числом в формате 31.01.2021 или 2021-01-31), время (показывать ли миллисекунды — это может быть важно для банковских транзакций), валюта и другие. Если реализация toString() в переданном объекте не подходит, её можно и нужно адаптировать.

```java
import java.util.Arrays;
class Address {

    public String city;
    public String street;
    public int houseNumber;
    public String extraInfo;
    public String[] residents;

    @Override
    public String toString() {
            String result = "Address{" +
                "city='" + city + '\'' +
                ", street='" + street + '\'' +
                ", houseNumber=" + houseNumber + '\'';

        if(extraInfo != null) {
            result = result + ", extraInfo.length=" + extraInfo.length();
        } else {
            result = result + ", extraInfo=null";
        }

        return result + ", residents=" + Arrays.toString(residents) + '}';
    }
}

public class Practicum {

    public static void main(String[] args) {
        Address house = new Address(); // cоздаём объект и инициализируем его поля
        house.city = "Комсомольск-на-Амуре";
        house.street = "Победы";
        house.houseNumber = 33;
        house.residents = new String[]{ "Агафон Лыков", "Ульяна Скрябина" };
        System.out.println(house.toString());
    }
}
```

Многие классы стандартной библиотеки String, Integer, Double, Short и другие уже имеют переопределённый toString(). При передаче их объектов в метод println()выводятся непосредственно значения, а не название класса с хеш-кодом. println() сам вызывает toString(). При конкатенации — оператор + также автоматически вызывает toString().

Класс, от которого наследуются все остальные классы.
Все объекты, включая массивы, реализуют методы этого класса
![[Приведение объекта к Object.png]]
## Методы класса Object
![[Методы класса Object.png]]
 [[Finalize|Метод finalize]]
### Каким образом реализованы методы hashCode() и equals() в классе Object?
**Реализация метода Object.equals()** сводится к проверке
на равенство двух ссылок:
![[equals в классе Object.png|400]]
**HashCode реализован** так, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.

**Реализация метода Object.hashCode()** описана как native, т.е. написана НЕ на ЯП Java.

Конкретная реализация зависит от версии Java
https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html
### Разница instanceof и getClass
- ` instanceof` проверяет, является ли ссылка на объект с левой стороны экземпляром типа с правой стороны или некоторым его подтипом.
- `getClass() ==` ... проверяет идентичность типов.

[[Equals и hashCode]]

[[Класс Class ]]
