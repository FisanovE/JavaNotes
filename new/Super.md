---
tags:
  - "#Super"
---


Для обращения к методам класса-родителя через super нужно применить точечную нотацию — super.someMethod()
```

class МирноеВремя {
   public double getPi() {
      return 3.14;
   }
}

class ВоенноеВремя extends МирноеВремя {
   public double getPi() {
      return super.getPi()*2;  // 3.14*2
   }
}
```

Можно обратиться также к скрытым полям родительского класса — super.someField

```
super.метод(параметры);
```

Необходимость обращаться через super к скрытым полям суперкласса — достаточно редкое явление. Во-первых, потому что увлекаться сокрытием полей не принято — так возрастает вероятность ошибки. Во-вторых, поля классов всё-таки лучше инициализировать не при объявлении, а в конструкторе.

Через super можно также вызвать конструктор класса-родителя. С помощью super() — без параметров, а с помощью super(parameter list) — с параметрами. parameter list подразумевает, что нужно передать определённое число параметров указанных типов.

```
class BiologyTeacher extends Teacher {
    int numberOfLabs; // число лабораторных работ
    
    public BiologyTeacher() {
      numberOfLabs = 10;  // здесь неявно вызван конструктор суперкласса     
    }
}

class BiologyTeacher extends Teacher {
    int numberOfLabs; // число лабораторных работ

    public BiologyTeacher() {
        super(); // здесь явно вызван конструктор суперкласса
        numberOfLabs = 10;
    }
}
```

Явно вызывать конструктор суперкласса без параметров — нет необходимости. Единственное исключение: для навигации в коде — зажав ctrl и кликнув на super(), можно быстро перейти в конструктор родителя.

```
super(parameter list)
```

Совсем другая история — наличие в классе-родителе конструктора с параметрами. В этом случае обойтись без вызова суперконструктора в классе-наследнике не получится — произойдёт ошибка компиляции.

IDEA в таком случае подскажет, что "There is no default constructor available in 'Teacher'" — англ. «в Teacher нет доступного конструктора по умолчанию». А при попытке запустить код компилятор выдаст ошибку: "constructor Teacher in class Teacher cannot be applied to given types"  — англ. «конструктор Teacher в классе Teacher не может быть применён к заданным типам».

Чтобы решить эту проблему, нужно либо создать в суперклассе конструктор без параметров, либо вызвать родительский конструктор.

Чтобы не дублировать код конструктора родителя в классе-наследнике, можно вызвать суперконструктор в конструкторе подкласса. Тогда общие поля будут проинициализированы в классе-родителе, а индивидуальные — в наследнике.

**_Важное правило!_** Вызов конструктора класса-родителя через super должен быть первой строкой в конструкторе класса-наследника. Иначе произойдёт ошибка "java: call to super must be first statement in constructor" — англ. «вызов super должен быть первым оператором в конструкторе». Так компилятор проверяет, что родительский класс был проинициализирован корректно ещё до создания дочернего класса.